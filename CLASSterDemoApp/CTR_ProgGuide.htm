<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<Title>Programmer's Guide</Title>
</HEAD>
<style type="text/css">
BODY
{
    FONT-SIZE: 8pt;
    BACKGROUND: #ffffff;
    PADDING-BOTTOM: 20pt;
    COLOR: #000000;
    PADDING-TOP: 20pt;
    FONT-FAMILY: Verdana, Arial, sans-serif
}
DIV
{
    BORDER-RIGHT: #999999 2px;
    PADDING-RIGHT: 0px;
    BORDER-TOP: #999999 2px;
    PADDING-LEFT: 0px;
    BACKGROUND-IMAGE: none;
    BORDER-LEFT: #999999 2px;
    WIDTH: 90%;
    BORDER-BOTTOM: #999999 2px;
    BACKGROUND-REPEAT: repeat
}
H1
{
    FONT-WEIGHT: bold;
    FONT-FAMILY: Tahoma, Arial, Verdana, Helvetica, sans-serif;
    TEXT-ALIGN: center
}
H2
{
    FONT-FAMILY: Verdana, Arial, Helvetica, sans-serif;
    TEXT-ALIGN: center
}
H3
{
    MARGIN-TOP: 3px;
    FONT-SIZE: 14pt;
    COLOR: royalblue;
    FONT-FAMILY: Arial, sans-serif, Verdana
}
H4
{
    MARGIN-TOP: 0pt;
    FONT-WEIGHT: bold;
    FONT-SIZE: 8pt;
    MARGIN-BOTTOM: 0px;
    PADDING-BOTTOM: 0px;
    COLOR: black;
    PADDING-TOP: 0px;
    FONT-FAMILY: Verdana, Arial, sans-serif
}
P
{
    MARGIN-TOP: 0px;
    FONT-SIZE: 8pt;
    PADDING-BOTTOM: 3pt;
    LINE-HEIGHT: normal;
    PADDING-TOP: 0px;
    TEXT-ALIGN: justify
}
UL
{
    MARGIN-TOP: 0.6em;
    MARGIN-BOTTOM: 0em
}
OL
{
    MARGIN-TOP: 0.6em;
    MARGIN-BOTTOM: 0em
}
OL
{
    MARGIN-LEFT: 3.6em
}
UL
{
    MARGIN-LEFT: 1.9em;
    LIST-STYLE-TYPE: disc
}
LI
{
    MARGIN-BOTTOM: 0.6em;
    TEXT-ALIGN: justify
}
PRE
{
    MARGIN-TOP: 0px;
    FONT-WEIGHT: normal;
    MARGIN-BOTTOM: 0px;
    FONT-STYLE: normal;
    FONT-FAMILY: Courier New, Courier, mono;
    FONT-VARIANT: normal
}
CODE
{
    FONT-WEIGHT: normal;
    FONT-SIZE: 10pt;
    COLOR: black;
    FONT-FAMILY: Courier New, Courier, mono
}
TABLE
{
    BACKGROUND-IMAGE: none;
    MARGIN-BOTTOM: 0em;
    WIDTH: 100%;
    BACKGROUND-REPEAT: repeat
}
TH
{
    PADDING-RIGHT: 8px;
    PADDING-LEFT: 8px;
    FONT-SIZE: 8pt;
    BACKGROUND: #cccccc;
    PADDING-BOTTOM: 4px;
    VERTICAL-ALIGN: bottom;
    PADDING-TOP: 4px;
    TEXT-ALIGN: left
}
TD
{
    PADDING-RIGHT: 8px;
    PADDING-LEFT: 8px;
    FONT-SIZE: 8pt;
    BACKGROUND-IMAGE: none;
    PADDING-BOTTOM: 4px;
    VERTICAL-ALIGN: top;
    PADDING-TOP: 4px;
    BACKGROUND-REPEAT: repeat
}
SUP
{
    FONT-SIZE: smaller;
    TEXT-DECORATION: none
}
A:link
{
    FONT-SIZE: 8pt;
    COLOR: #0066ff;
    TEXT-DECORATION: none
}
A:visited
{
    FONT-SIZE: 8pt;
    COLOR: #0066ff;
    TEXT-DECORATION: none
}
A:hover
{
    FONT-SIZE: 8pt;
    COLOR: #cc9900;
    TEXT-DECORATION: none
}
H5
{
    FONT-SIZE: 10pt;
    COLOR: #336666;
    FONT-FAMILY: Verdana, Arial;
    TEXT-ALIGN: left
}
H6
{
    MARGIN-TOP: 3px;
    FONT-WEIGHT: bold;
    FONT-SIZE: 8pt;
    MARGIN-BOTTOM: 3px;
    COLOR: #0066ff
}

</style>

<BODY>

<h1>CLASS<EM>ter</EM></h1>
<h3 align=center>Programmer's Guide to Database Class</h3>
<h4 align=center>Version 2.0, All Editions. </h4>
<p>&nbsp;
<p><center>
Copyright URFIN JUS (<A HREF="http://www.urfinjus.net">www.urfinjus.net</A>), 2001-2002. All Rights Reserved.
</center>
<p>&nbsp;
<p>&nbsp;
<A name="Contents"><h3>Contents</h3></A>
<UL>
	<LI><a href="#Introduction">Introduction</a>
	<LI><a href="#CreateInstance">Creating and Initializing Class Instance</a>
	<LI><a href="#CallSPs">Calling Stored Procedures</a>
	<LI><a href="#ExecSPbyName">Using ExecSPbyName Method</a>
	<LI><a href="#ReturnRS">Returning Recordset from Stored Procedure</a>
	<LI><a href="#Recordset">Accessing the Returned Recordset</a>
	<LI><a href="#MethRecordset">Methods for Accessing Data In Recordset</a>
	<LI><a href="#ExecSQL">Executing SQL Statements</a>
	<LI><a href="#ExecParamSQL1">Parameterized SQL Statements, Method 1: Embedded Parameters</a>
	<LI><a href="#ExecParamSQL2">Parameterized SQL Statements, Method 2: Using Parameters Collection</a>
	<LI><a href="#MultiRS">Retrieving Multiple Recordsets</a>
	<LI><a href="#SkipClosed">Skipping Closed Recordsets</a>
	<LI><a href="#ErrH">Error Handling</a>
	<LI><a href="#Nulls">Sending Null Values to Database</a>
	<LI><a href="#Trans">Controlling Transactions: Overview</a>
	<LI><a href="#ADOTrans">ADO Transactions</a>
	<LI><a href="#COMPTrans">COM+ Transactions</a>
	<LI><a href="#Batch">Batch Execution</a>
	<LI><a href="#XML">XML: Two Levels of XML Support</a>
	<LI><a href="#XMLBasic">Basic XML Functionality</a>
	<LI><a href="#XMLAdvanced">Advanced XML Functionality</a>
	<LI><a href="#Problems">Known Problems</a>
</UL>

<p>&nbsp;
<p>&nbsp;

<HR>
<a name="Introduction"/>
<h3>Introduction</h3>
<p>This document provides information and guiding instructions on
using VB class automatically generated by CLASSter 2.0. 
Hereafter this class is referred to as <EM>database class</EM>. 
All information provided and code samples are by default applicable
to MS SQL Server database server. Limitations and 
differences for servers other than MS SQL Server
are mentioned in notes. 
<p>Not all functionality described 
in this document is available for all server brands. 
Additionally, many features are interdependent, 
so certain functionality  may be available only if support for other feature, on 
which it is dependent, is included into database class. 
Most of the time if certain option is disabled in CLASSter it means
that this functionality is not available, either at all for this type
of server, or because of other selections you made in CLASSter. 
<table border='0' cellpadding=0  width='100'> <tr valign='top'><td align=right>
<a href="#Contents">Contents</a></table>

<HR>
<a name="CreateInstance"/>
<h3>Creating and Initializing Class Instance</h3>
<p>As with any other class before you start using database class in your code
you must create and initialize its instance. You have three ways of creating object instance in VB:
<p>1. Declaring object variable with <EM>New</EM> keyword: 
<table border='0' cellpadding=0  width="90%"> <tr valign='top'><td bgcolor=#F0F0F0>
<code><pre>
<font color="#000080">Dim</font> objMainDB <font color="#000080">As</font> New clsMainDB</pre></code>
</td></tr></table>
<p>You can use the object without explicitly creating its instance - VB will do it automatically. 	
<p>2. Using <EM>New</EM> operator of Visual Basic:
<table border='0' cellpadding=0   width="90%"> <tr valign='top'><td bgcolor=#F0F0F0>
<code><pre>
<font color="#000080">Dim</font> objMainDB <font color="#000080">As</font> clsMainDB
<font color="#000080">Set</font> objMainDB = New clsMainDB</pre></code>
</td></tr></table>	
<p>3. Using <EM>CreateObject</EM> function:
<table border='0' cellpadding=0   width="90%"> <tr valign='top'><td bgcolor=#F0F0F0>
<code><pre>
<font color="#000080">Dim</font> objMainDB <font color="#000080">As</font> clsMainDB
<font color="#000080">Set</font> objMainDB = CreateObject(<font color="#808080">&quot;AppLib.clsMainDB&quot;</font>)</pre></code>
</td></tr></table>
<p>Most of the time the best choice is method 2 (<EM>New</EM> operator). 
In most cases there is no difference between <EM>New</EM> operator and 
<EM>CreateObject</EM> function, except <EM>New</EM> works a bit faster. The only situation when the effect is different is
when you are running your COM DLL as COM+ application and both database class  
and instantiating code are located in the same COM DLL. In this case if you 
use <EM>New</EM> operator then object creation process will not go through COM+ services, 
and COM+ environment will know nothing about created object. As a result, 
COM+ services will not be available to the object. 
Most likely this is not what you want, so your code must use <EM>CreateObject</EM> function
in this case. 
<p>After creating class instance you may need to initialize it. Your code may need to
 assign <EM>ConnectionString</EM> property (if you didn't select "automatic" source of connection
 information in CLASSter, like Registry). 
<p>You may also want to change some internal flags that control database class functionality. 
These flags are available through <EM>Options</EM> property. You would do this only if the options
you need are different from initial options you've specified in CLASSter for your 
database class. Another thing you will sometimes do is provide connection string 
to database where error log table is located. 
<p>Your start-up code may look like this:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
<font color="#000080">Dim</font> objMainDB <font color="#000080">As</font> clsMainDB
<font color="#000080">Set</font> objMainDB = New clsMainDB
<font color="#000080">With</font> objMainDB
    .ConnectionString = STR_CONNECT_MAIN
    .ConnectionString4Err = STR_CONNECT_ERRLOG
    .Options(CTRO_ERR_RAISE) = False
<font color="#000080">End</font> <font color="#000080">With</font> </pre></code>
</td></tr></table>
<p>If you have application-global <EM>Connection</EM> object and want your database class 
to use it instead of creating new <EM>Connection</EM>, 
then you should provide it to class instance through <EM>Connection</EM> property, 
instead of assigning <EM>ConnectionString</EM>:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
<font color="#000080">Set</font> objMainDB = New clsMainDB
<font color="#000080">Set</font> objMainDB.Connection = gobjConnection
</pre></code>
</td></tr></table>
<p>That's it - your database class instance is ready to execute database operations.
<table border='0' cellpadding=0  width='100'> <tr valign='top'><td align=right>
<a href="#Contents">Contents</a></table>
 
<HR><a name="CallSPs"/>
<h3>Calling Stored Procedures</h3>
<p>You call stored procedure in database by simply calling a method of database class
with matching name. For example:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
objMainDB.ExecGetCustNameByID CustID, CustName
</pre></code>
</td></tr></table>
<p>The stored procedure name is probably 'cust_get_name_by_id', and CLASSter-generated
method declaration is the following:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
<font color="#000080">Public</font> <font color="#000080">Function</font> ExecGetCustNameByID(<font color="#000080">ByVal</font> CustID <font color="#000080">As</font> <font color="#000080">Long</font>, _
    <font color="#000080">ByRef</font> CustName <font color="#000080">As</font> <font color="#000080">String</font>) <font color="#000080">As</font> <font color="#000080">Boolean</font> 
</pre></code>
</td></tr></table>
<p>CustName is declared <EM>ByRef</EM>, because corresponding parameter of stored procedure is declared <EM>OUTPUT</EM>
(<EM>OUT</EM> for Oracle). If everything goes OK then our call would return some value 
in <EM>CustName</EM> parameter. 

<p>You could force CLASSter to make all parameters <EM>ByVal</EM> by selecting corresponding option
in CLASSter. In this case you can still retrieve parameter value returned by stored procedure:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
objMainDB.ExecGetCustNameByID CustID, CustName
CustName = objMainDB.ParamValue(<font color="#808080">&quot;@cust_name&quot;</font>)
</pre></code>
</td></tr></table>
<p>If your stored procedure returns recordset as a result of SELECT SQL query then you can retrieve
the ADO Recordset object:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
objMainDB.ExecCustomersGetByState StateId
<font color="#000080">Set</font> rsCustomers = objMainDB.Recordset
</pre></code>
</td></tr></table>
<p>See <a href="#Recordset">Accessing Returned Recordsets</a> 
section for more information 
about working with data returned in Recordset.
<table border='0' cellpadding=0  width='100'> <tr valign='top'><td align=right>
<a href="#Contents">Contents</a></table>

<HR><a name="ExecSPbyName"/>
<h3>Using ExecSPbyName Method</h3>
<p>We've just seen one method to call stored procedure - through individual class functions, 
with names matching names of stored procedures.
<p>CLASSter provides alternative way to call stored procedures. You can call any 
stored procedure using function <EM>ExecSPbyName</EM>. The main difference between 
these two approaches is in the way <EM>Command.Parameters</EM> collection is prepared.
For individual methods this process is hard-coded into method body.
<EM>ExecSPbyName</EM> rebuilds parameters using information
packed into string constants. These constants are prepared by CLASSter, and
are placed into separate .Bas module. 
You provide a constant with packed parameters definitions as an argument to <EM>ExecSPbyName</EM> 
together with procedure name and array of parameter values.  
Additionally CLASSter generates constants with 
stored procedures names to help you to avoid mistakes when you type the name  
in a  call to <EM>ExecSPbyName</EM>.
<p>Parameter definition constants start with prefix <EM>PRM_</EM> 
followed by stored procedure name (possibly a bit transformed); 
procedure name constants have <EM>SP_</EM> prefix also followed by procedure name. 
<p>Example:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
objMainDB.ExecSPbyName SP_SALES_BY_YEAR, PRM_SALES_BY_YEAR, _
    Array(datBeginDate, datEndDate)
</pre></code>
</td></tr></table>
<p>If stored procedure has output parameters, you can retrieve them after the call 
using <EM>ParamValue</EM> property. <EM>ExecSPbyName</EM> fully supports all 
Null-substituting functionality. It can be used in Batch mode just like 
individual calling methods. 
<table border='0' cellpadding=0  width='100'> <tr valign='top'><td align=right>
<a href="#Contents">Contents</a></table>

<HR><a name="ReturnRS"/>
<h3>Returning Recordset from Stored Procedure</h3>
<p>All database servers supported by CLASSter can return data in 
Recordset from stored procedure, although you do it in different ways
for each server. 
<p>For MS SQL Server, Sybase servers and MS Access returning Recordset 
is simple: whenever you execute SELECT statement without INTO clause 
in your stored procedure the resulting data is returned as a Recordset. 
If you execute several SQL statements (not available for MS Access), 
then server would return a chain or sequence of Recordsets  
(see <a href="#MultiRS">Retrieving Multiple Recordsets</a> section).
<p>For Oracle server returning recordset is a bit trickier. 
PL/SQL doesn't allow executing SELECT statement without INTO clause
inside stored procedure. You must provide Cursor variable for any 
SELECT statement. If this cursor variable is output parameter of 
stored procedure then selected data would be returned as Recordset 
to VB. You also need to declare Ref Cursor type in one of your packages. 
<p>Example:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
   -- In package specification 	
   type   RefCursor Is Ref Cursor; 
   Procedure CustomerGetByID(CustID IN Number,
                             curCustomer OUT RefCursor);

   -- In package body:
   Procedure CustomerGetByID(CustID IN Number,
                             curCustomer OUT RefCursor) Is
     begin
        Open curCustomer for Select * from Customers where customer_id = CustID;
     End;
</pre></code>
</td></tr></table>
<p>VB method in your database class will have only one parameter for <EM>CustID</EM>. CLASSter will
not include <EM>curCustomer</EM> in parameter list. After calling the method you can access customer 
record through <EM>Recordset</EM> property of your database class. 
<p>See Microsoft and Oracle documentation to get more information on returning Recordsets from Oracle. 
See next section for more about accessing data in <EM>Recordsets</EM>. 
<table border='0' cellpadding=0  width='100'> <tr valign='top'><td align=right>
<a href="#Contents">Contents</a></table>

<HR>
<a name="Recordset"/>
<h3>Accessing the Returned Recordset</h3>
<p>If stored procedure or SQL statement return <EM>Recordset</EM> then it would be 
 available through <EM>Recordset</EM> property of your database class:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
<font color="#000080">With</font> objMainDB
    .ExecCustGetAll
    <font color="#000080">Set</font> rsCust = .Recordset
    .ExecOrdersGetByCustID CustID
    <font color="#000080">Set</font> rsOrders = .Recordset
<font color="#000080">End</font> <font color="#000080">With</font>
</pre></code>
</td></tr></table>
<p>Database class does not reuse <EM>Recordset</EM> object, 
but creates a new instance for each database operation.
If database operation does not return recordset (for example, it is 
UPDATE statement) then <EM>Recordset</EM> object still would be created, but its
<EM>State</EM> property set to <EM>adStateClosed</EM>.
You cannot access any properties like <EM>Fields</EM> or <EM>RecordCount</EM> for such a <EM>Recordset</EM>. 
<table border='0' cellpadding=0  width='100'> <tr valign='top'><td align=right>
<a href="#Contents">Contents</a></table>



<HR><a name="MethRecordset"/>
<h3>Methods for Accessing Data In Recordset</h3>
<p><EM>Note: to use methods described in this section you must check the corresponding boxes in 
[Class Functionality / ADO Helper Methods] page in CLASSter, so it includes these methods 
into your database class. </EM>
<p>After calling stored procedure, which returns data in <EM>ADO Recordset</EM> you can navigate through
it and retrieve field values using convenient CLASSter-added methods of your class:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
<font color="#000080">With</font> objMainDB
    .ExecCustomersGetByState StateId
    <font color="#000080">While</font> <font color="#000080">Not</font> .EOF
        MsgBox <font color="#808080">&quot;Customer: &quot;</font> &amp; .Value(<font color="#808080">&quot;last_name&quot;</font>)
        .MoveNext
    <font color="#000080">Wend</font>
<font color="#000080">End</font> <font color="#000080">With</font>
</pre></code>
</td></tr></table>
<p>What is good about <EM>Value</EM> property is that it is Null-safe. If field value is Null, it returns 
variant Empty value, which is safe to assign to VB variable of any type.  
<p>You can use <EM>RecordCount</EM> property to retrieve number of records returned from database. 
If you need to check if there is at least one record in <EM>Recordset</EM> then use <EM>HasRecords</EM> property of 
your database class. It returns false if both <EM>EOF</EM> and <EM>BOF</EM> properties of Recordset object are true. 
<p>You can use automatic formatting functionality of your class to easily format field values. 
You set format for particular field name and/or data type. You do it once, and then use 
<EM>ValueFmt</EM> property 
many times, even with different recordsets to retrieve automatically-formatted values:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
<font color="#000080">With</font> objMainDB
    .FormatSet <font color="#808080">&quot;MMM-DD-YYYY&quot;</font>, adDBTimeStamp
    <font color="#000080">While</font> <font color="#000080">Not</font> .EOF
        MsgBox <font color="#808080">&quot;Customer: &quot;</font> &amp; .Value(<font color="#808080">&quot;last_name&quot;</font>) &amp; _
            <font color="#808080">&quot; created: &quot;</font> &amp; .ValueFmt(<font color="#808080">&quot;date_created&quot;</font>)
        .MoveNext
    <font color="#000080">Wend</font>
<font color="#000080">End</font> <font color="#000080">With</font>
</pre></code>
</td></tr></table>
<p>You can call <EM>FormatSet</EM> many times to specify format string 
for different field names or data types. The second parameter of <EM>FormatSet</EM> is <EM>ParamArray</EM>,
so you can provide the whole list of names/types. To remove formatting 
for field name or type just call <EM>FormatSet</EM> with empty format string. 
We could use <EM>ValueFmt</EM> property for <EM>last_name</EM> field as well - if format is not
specified for field or data type then <EM>ValueFmt</EM> returns the same value as <EM>Value</EM> property.
<p>Note that when you specify format string for data type, it is ADO data type constant that you should
provide, not VB type. 
<p>Both <EM>Value</EM> and <EM>ValueFmt</EM> properties are Null-safe: 
if underlying field value is Null, then <EM>Value</EM> returns VB Empty value, 
and <EM>ValueFmt</EM> returns empty string. 
This saves you from checking fields for Null before assigning values to VB variables. 
<table border='0' cellpadding=0  width='100'> <tr valign='top'><td align=right>
<a href="#Contents">Contents</a></table>

<HR>
<a name="ExecSQL"/>
<h3>Executing SQL Statements</h3>
<p><EM>Note: You can use functions described in this section only if you checked the corresponding
checkbox in [Class Functionality / SQL] page in CLASSter. </EM>
<p>You can easily execute SQL statements in your database:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
<font color="#000080">With</font> objMainDB
    .ExecSQL <font color="#808080">&quot;SELECT * FROM Customers WHERE cust_id=&quot;</font> &amp; CustID
    <font color="#000080">If</font> .HasRecords <font color="#000080">Then</font> MsgBox <font color="#808080">&quot;Customer found: &quot;</font> &amp; .Value(<font color="#808080">&quot;last_name&quot;</font>)
<font color="#000080">End</font> <font color="#000080">With</font>
</pre></code>
</td></tr></table>
<p>You can navigate the returned <EM>Recordset</EM> object in the way we have already shown in previous sections. 
<p>SQL statement shown in this example is created dynamically by attaching a parameter to 
SQL template. It is in fact parameterized SQL statement, and your database class has convenient methods
for executing dynamic SQLs easily. 
CLASSter equips your class with two methods to run parameterized SQLs.
The following sections explain both methods.
<table border='0' cellpadding=0  width='100'> <tr valign='top'><td align=right>
<a href="#Contents">Contents</a></table>

<HR>
<a name="ExecParamSQL1"/>
<h3>Parameterized SQL Statements, Method 1: Embedded Parameters</h3>
<p>With the first method parameters are directly embedded into SQL statement text in places identified by placeholders. 
Values of parameters are provided in <EM>Variant</EM> array as second optional 
parameter of <EM>ExecSQL</EM> method.
<p>The following SQL statement finds customer by last name in a given state:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
<font color="#000080">With</font> objMainDB
    .ExecSQL <font color="#808080">&quot;SELECT * FROM Customers WHERE state_id=%1 AND last_name='%2' &quot;</font>, _
        Array(AStateID, ALastName)
    <font color="#000080">If</font> .HasRecords <font color="#000080">Then</font> MsgBox <font color="#808080">&quot;Customer found in &quot;</font> &amp; .Value(<font color="#808080">&quot;city&quot;</font>)
<font color="#000080">End</font> <font color="#000080">With</font>
</pre></code>
</td></tr></table>
<p><EM>ExecSQL</EM> would recognize that <EM>Values(</EM>) parameter is provided,
 so it would replace placeholders with values from Values array. It replaces <EM>%1</EM> with <EM>Values(0)</EM>, and 
<EM>%2</EM> with Values(1) - notice the index shift.    
After replacing placeholders with actual parameters <EM>ExecSQL</EM> executes statement in database. 
<p>Note that placeholder <EM>%2</EM> is embraced in quotes in SQL template - <EM>ExecSQL</EM> doesn't add quotes automatically.
However, <EM>ExecSQL</EM> does another thing: according to SQL rules
every occurrence of a single quote inside string constant must be doubled. 
And <EM>ExecSQL</EM> does this doubling automatically, you don't need to worry about this. 
In the above example method wouldn't fail if we were searching for last name O'Neil - 
<EM>ExecSQL</EM> will do things correctly.
<table border='0' cellpadding=0  width='100'> <tr valign='top'><td align=right>
<a href="#Contents">Contents</a></table>
 
<HR>
<a name="ExecParamSQL2"/>
<h3>Parameterized SQL Statements, Method 2: Using Parameters Collection</h3>
<p>With the second approach parameter values are not embedded into SQL statement before execution. 
Instead, database class uses functionality of underlying provider/driver to execute parameterized SQLs. 
With this approach SQL statement denotes parameters using "?" character, parameter values are put into 
<EM>Command.Parameters</EM> collection, not embedded into SQL text. 
<p>Example:  
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
<font color="#000080">With</font> objMainDB
    .AddSQLParam AStateID
    .AddSQLParam ACustName, , , adVarChar, 50
    .ExecSQL <font color="#808080">&quot;SELECT * FROM Customers WHERE state_id=? AND last_name=? &quot;</font>
    <font color="#000080">If</font> .HasRecords <font color="#000080">Then</font> MsgBox <font color="#808080">&quot;Customer found in &quot;</font> &amp; .Value(<font color="#808080">&quot;city&quot;</font>)
<font color="#000080">End</font> <font color="#000080">With</font>
</pre></code>
</td></tr></table>
<p><EM>AddSQLParam</EM> has several parameters,  all optional. These parameters are in fact attributes of 
ADO <EM>Parameter</EM> object being added to <EM>Command.Parameters</EM> collection. 
Here is declaration of <EM>AddSQLParam</EM> method in your database class:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
<font color="#000080">Public</font> <font color="#000080">Function</font> AddSQLParam(<font color="#000080">Optional</font> <font color="#000080">ByVal</font> PValue <font color="#000080">As</font> <font color="#000080">Variant</font>, _
       <font color="#000080">Optional</font> <font color="#000080">ByVal</font> PName <font color="#000080">As</font> <font color="#000080">String</font>, _
       <font color="#000080">Optional</font> <font color="#000080">ByVal</font> PDir <font color="#000080">As</font> ADODB.ParameterDirectionEnum = adParamInput, _
       <font color="#000080">Optional</font> <font color="#000080">ByVal</font> PType <font color="#000080">As</font> ADODB.DataTypeEnum = adInteger, _
       <font color="#000080">Optional</font> <font color="#000080">ByVal</font> PSize <font color="#000080">As</font> <font color="#000080">Long</font> = 0, _
       <font color="#000080">Optional</font> <font color="#000080">ByVal</font> IsNullableFK <font color="#000080">As</font> <font color="#000080">Boolean</font> = False) <font color="#000080">As</font> <font color="#000080">Boolean</font>
</pre></code>
</td></tr></table>
<p>Some of parameters have default values. 
That is why  in the first call to <EM>AddSQLParam</EM> (for <EM>AStateID</EM>)
we provided only <EM>PValue</EM> argument  - we simply relied on defaults.
For <EM>ACustName</EM> parameter we had to specify explicitly <EM>PType</EM> and <EM>PSize</EM>. 
<EM>PSize</EM> is always required for <EM>adVarChar</EM> parameters. If you don't provide parameter
name you still can retrieve it by parameter index. <EM>IsNullableFK</EM> is provided to facilitate working
with Nullable numeric parameters (which often hold foreign key values hence the argument name). 
If <EM>IsNullableFK</EM> is True, and <EM>PValue</EM> is zero, then <EM>AddSQLParam</EM> will substitute zero with Null. 
<p>As you see this method of executing parameterized SQLs is a bit more complex than the one with embedded parameters. 
However it has its advantages: first, it allows binary data types; second, it allows output parameters:  
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
<font color="#000080">With</font> objMainDB
    .AddSQLParam , <font color="#808080">&quot;CustCity&quot;</font>, adParamOutput, adVarChar, 50
    .AddSQLParam AStateID
    .AddSQLParam ACustName, , , adVarChar, 50
    .ExecSQL <font color="#808080">&quot;SELECT ? = city FROM Customers WHERE state_id=? AND last_name=? &quot;</font>
    <font color="#000080">If</font> .HasRecords <font color="#000080">Then</font> MsgBox <font color="#808080">&quot;Customer found in &quot;</font> &amp; .ParamValue(<font color="#808080">&quot;CustCity&quot;</font>)
<font color="#000080">End</font> <font color="#000080">With</font>
</pre></code>
</td></tr></table>
<p>This SQL finds customer city and returns it as a parameter, not as a field in <EM>Recordset</EM>. 
We specified parameter name in order to retrieve its value by name later, but this is not 
required - we could do it by parameter index (0 in this case). 
<p>You can combine both methods of executing parameterized SQL. In one SQL statement you can have 
some parameters specified through <EM>AddSQLParam</EM>, and others as embedded parameters with <EM>%N</EM> placeholders.
<p><EM>Note: output SQL parameters are not supported by Oracle server. </EM>
<table border='0' cellpadding=0  width='100'> <tr valign='top'><td align=right>
<a href="#Contents">Contents</a></table>

<HR>
<a name="MultiRS"/>
<h3>Retrieving Multiple Recordsets</h3>
<p><EM>Note: functionality described in this section is available only for MS SQL Server and Sybase ASE servers. Methods
implementing support for multiple Recordsets are included in database class 
if user checks the corresponding checkbox in [Class Functionality / ADO Helper Functions] page in CLASSter. </EM>
<p>MS SQL Server, Sybase ASE and their OLE DB Providers allow you to retrieve several 
recordsets in one database operation. Stored procedure 
may execute several SELECT statements, and results will be returned in several recordsets. 
Or application may execute a command with several SQLs. When such a command is executed the first
returned <EM>Recordset</EM> becomes current and is available through <EM>Recordset</EM> property of database 
class. After processing the first <EM>Recordset</EM> application can move to the next Recordset in
returned sequence by calling <EM>SelectNextRecordset</EM> function. It returns True if next recordset
exists and was retrieved successfully. After processing second Recordset application calls 
<EM>SelectNextRecordset</EM> again, and so on, until this function returns False meaning that the end 
of recordsets sequence is reached. 
<p>Here is an example:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
<font color="#000080">With</font> objMainDB
    .ExecSQL <font color="#808080">&quot;SELECT * FROM Customers WHERE customer_id = %1; &quot;</font> &amp; _
        <font color="#808080">&quot;SELECT * FROM Orders WHERE customer_id = %1; &quot;</font>, ACustID
    <font color="#000080">Set</font> rsCustomers = .Recordset
    <font color="#008000">'Fully process rsCustomers here</font>
    .SelectNextRecordset
    <font color="#000080">Set</font> rsOrders = .Recordset
    <font color="#008000">'Now process rsOrders. rsCustomers is destroyed</font>
<font color="#000080">End</font> <font color="#000080">With</font>
</pre></code>
</td></tr></table>
<p>Note that single embedded SQL parameter may be provided as is, without putting it into array. 
Also, you can have more than one placeholder referencing the same parameter value.
<p>The result of execution of last SQL statement is two 
<EM>Recordsets</EM>. Note that you get several recordsets if 
several SELECT statements are executed in ONE operation. 
If in previous example we have called <EM>ExecSQL</EM> twice, with one <EM>SELECT</EM> statement
in each call, then this wouldn't bring two recordsets.
<p>With multiple recordsets what is being returned is not a collection, 
but sequence, in which only one recordset is available at a time. 
And this sequence is a 'one-way-street' - you are not able to go back to previous
element in sequence.
When you call <EM>SelectNextRecordset</EM> current <EM>Recordset</EM> is destroyed by ADO, and it doesn't help
if you save reference to it in some local variable. 
Don't try to save <EM>Recordsets</EM> in variables or collections -  this wouldn't work. 
Application must complete processing current <EM>Recordset</EM> (finish with it, 
read all data it needs) before selecting the next one. 
<table border='0' cellpadding=0  width='100'> <tr valign='top'><td align=right>
<a href="#Contents">Contents</a></table>

<HR>
<a name="SkipClosed"/>
<h3>Skipping Closed Recordsets</h3>
<p>There is one little annoyance that comes up when you work with multiple recordsets. 
As we have seen, each SELECT command in compound SQL statement contributes one Recordset to
returned sequence. However, other SQL commands (UPDATE, INSERT and DELETE) also contribute
Recordsets, even although they don't return any data. These Recordsets don't contain data, 
and if you check <EM>Recodset's</EM> state you'll see that it is <EM>adStateClosed</EM>.
Your application should simply skip such closed objects if they appear in sequence.  
<p>In dealing with closed recordsets in returned sequences you have three options: 
<UL>
	<LI>Instruct server not to return closed Recordsets produced by INSERT, DELETE or UPDATE
	commands by putting [SET NOCOUNT ON] T-SQL command at the beginning of all stored procedures or 
	compound SQL statements. 
	<LI>Call <EM>SkipClosedRecordsets</EM> method of your database class each time you 
	execute database command, and after every <EM>SelectNextRecordset</EM> call. This method
	checks current <EM>Recordset's</EM> state, and if it is closed it moves  
	along the sequence until it finds the open one or the sequence is over. 
	<LI>Set <EM>CTRO_AUTO_SKIPCLOSED</EM> flag through <EM>Options</EM> property of your database class, 
	and it will call <EM>SkipClosedRecordsets</EM> automatically. 
</UL>
<table border='0' cellpadding=0  width='100'> <tr valign='top'><td align=right>
<a href="#Contents">Contents</a></table>
 
<HR>
<a name="ErrH"/>
<h3>Error Handling</h3>
<p>Before adding CLASSter-generated database class to your Visual Basic project
you should make some major architectural decisions. You should decide how errors
will be handled inside database class, and how class error-handling functionality
will fit into general error handling architecture of your application. 
<p>You probably already know about HuntERR. 
HuntERR is error-handling solution for Visual Basic that was designed by URFIN JUS 
and is available for free. It is the most powerful and complete error-handling 
solution for Visual Basic available today. HuntERR Zip file is included into 
CLASSter installation package. If you are not familiar with HuntERR we recommend 
you to have a look at HuntERR demo application, and to read <EM>HuntERR Programmer's Guide</EM>. 
<p>One of the most valuable CLASSter features is that it can generate  
fully HuntERR-compatible code. However, using HuntERR is not required. You can choose
not to use it, and CLASSter will generate database class that has some error-handling code 
in place. This code doesn't rely on HuntERR and provides just minimum 
error-handling functionality. Some of the features, like automatic error logging, 
are available only through HuntERR.  Although HuntERR use is optional 
we strongly advise you to use it for handling errors in your database class, and probably
in the entire application.  
<p>In any case CLASSter-generated database class has error handlers in place, so 
all errors are handled and processed in some way inside class. All error information
is automatically saved in internal class properties, and may be accessed by  
application after returning from failed method. If database class doesn't 
re-raise errors, detecting the success/failure outcome is easy. Most 
of the methods are functions returning Boolean value with True indicating success, and
False indicating failure. 
<p>After deciding about using HuntERR, the next choice you make is whether errors should 
be re-raised from database class. 
We recommend to re-raise errors for classes created and manipulated by another COM class, 
and not to re-raise them for classes called directly by VBSrcript code. 
The behavior regarding re-raising errors is controlled by internal flag <EM>CTRO_ERR_RAISE</EM>, 
which may be set/reset by application code at runtime through <EM>Options</EM> property. 
You specify the initial value of this flag in CLASSter.  
<p>The next decision is about error logging. CLASSter can add special code to database class 
that automatically logs error information to either system event log, text file, or 
database table. These features are handled through corresponding HuntERR functions, and are
available only if you choose to use HuntERR for handling errors in your database class. 
<p>The last thing to decide is automatic actions executed by database class in case of error.
These actions are controlled by internal flags that are available through <EM>Options</EM> property
at runtime. You specify initial values for these flags in CLASSter. The following 
automatic error actions are supported: aborting/disabling transaction, closing connection, 
releasing ADO <EM>Connection</EM> object. 
<p>Here is the summary checklist of things you should decide on in regards to error handling:
<UL>
	<LI>Use/Not use HuntERR
	<LI>Re-raise/not re-raise errors in database class
	<LI>Error logging options: no logging, event log, text file, database table.
	<LI>Automatic actions on error: aborting transactions, closing/releasing connections   
</UL>	 
<p>We cannot recommend one single set of error handling options for you to use. 
These options depend on your application's architecture and execution environment. 
However, we can recommend most common settings for two distinctively different 
environments. For both of them we recommend to use HuntERR. 
<UL>
	<LI><STRONG>Database class used directly from ASP/VBScript in WEB application:</STRONG> 
	Errors are not raised from database class. Transactions are automatically aborted in case of error.
	Error information is logged automatically to database table or
	text file.  Connection is closed and connection object is released
	<LI><STRONG>Database class used by other COM class:</STRONG> Errors are re-raised in
	class methods.	No automatic transaction action, no error logging. 
	These activities are responsibilities of the caller (your application code). 
</UL>
<p>You can find samples of application code using database class with error handling code 
in place in the following sections that explain transaction control functionality. 
<table border='0' cellpadding=0  width='100'> <tr valign='top'><td align=right>
<a href="#Contents">Contents</a></table>

<HR><a name="Nulls"/>
<h3>Sending Null Values to Database</h3>
<p>One of the annoyances that trouble VB developer in database applications is handling 
Null values. The problem is that normal "typed" VB variables cannot hold Nulls. 
The only Nullable VB type is Variant. On the other hand, database values are 
Nullable, and stored procedure parameters can hold Nulls. 
For database class generated by CLASSter the problem is this:
<EM>How to send Null value to stored procedure parameter represented by typed non-Variant 
parameter in VB?</EM> 
<p>It may seem that the only solution is to have Variant type for all VB variables 
or parameters that have Nullable counterparts in database. Giving up data types 
seems like giving up too much. CLASSter provides robust solution for the problem.  
<p>CLASSter puts special code in your database class that can performs 
automatic substitution of certain reserved values for Null. 
The following is brief outline of how it works for Numeric types, String and Date types
separately.
<h4>String types: all variable and fixed-length character/string database types</h4>
<p>The value being substituted is empty string. Substitute takes place for all parameters
of string type(s) if internal flag <EM>CTRO_NULL_EMPTYSTR</EM> is set. Application can change
the value of this flag at run-time through <EM>Options</EM> property of database class. 
<h4>Date/Time types</h4>
<p>The value being substituted is numeric zero. Visual Basic evaluates zero date to 
12/30/1899. Substitute takes place for all Date-type parameters
if internal flag <EM>CTRO_NULL_ZERODATE</EM> is set. Application can change
the value of this flag at run-time through <EM>Options</EM> property of database class. 
To turn substitution ON, this flag must be set, to turn off - reset. 
<h4>Numeric types: All integer types, Single, Double, NUMBER database types</h4>
<p>The value being substituted for Null is 0. There is no mass-substitute flag 
that turns this substituting ON for all such parameters, as it happens for Date and
String data types. 
Most often you need to send Null as a value of numeric parameter when this parameter
is a Nullable foreign key. Names of such parameters are usually easily identifiable:
they have a suffix like "ID" or "_id". You can specify these name patterns for these Nullable parameters
in CLASSter, so it is able to detect them. CLASSter then puts a special flag into generated
code that identifies that for this parameter 0 should be substituted with Null.  
If you look inside methods calling stored procedures you will notice <EM>ZERO_AS_NULL</EM>
argument (which is simply Boolean TRUE constant) in some calls to <EM>AddParam</EM> method. This 
argument indicates to <EM>AddParam</EM> that if parameter value is 0, 
then it should be substituted with Null. These flags are hard-coded into database class code, 
and the behavior cannot be changed at runtime. 
<p>Example: 
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
<font color="#000080">With</font> objMainDB
    .Options(CTRO_NULL_EMPTYSTR) = True
    .Options(CTRO_NULL_ZERODATE) = True
    lngProdID = 123
    strPriceCode = <font color="#808080">&quot;&quot;</font>
    datExpirDate = 0
    lngDiscountID = 0
    <font color="#008000">'All parameters except lngProdID will be sent as Null to database</font>
    .ExecProductUpdate lngProdID, strPriceCode, datExpirDate, lngDiscountID
<font color="#000080">End</font> <font color="#000080">With</font>
</pre></code>
</td></tr></table>
<p>The example assumes that the last parameter of stored procedure has name like <EM>@discount_id</EM>, 
and that user specified [*_id] as pattern for nullable foreign keys in CLASSter. 
<p><EM>Note: CLASSter puts a flag indicating the need for 0-Null substitution 
for each parameter into parameter definition strings used by ExecSPbyName, 
so it handles nullable parameters in the same way.</EM>
<table border='0' cellpadding=0  width='100'> <tr valign='top'><td align=right>
<a href="#Contents">Contents</a></table>

<HR>
<a name="Trans"/>
<h3>Controlling Transactions: Overview</h3>
<p>You can easily control database transactions through you database class. 
If you select any option other than [No Transaction Control] in [Class Functionality / Transactions]
page in CLASSter then CLASSter adds three methods to your database class: 
<EM>BeginTransaction</EM>, <EM>SetComplete</EM> and <EM>SetAbort</EM>. These methods provide 
control over server transactions. What these methods do depends on transaction control method 
you selected. There are two different ways to control transactions in your 
application: 
<UL>
	<LI>Through methods of ADO Connection object: <EM>BeginTrans</EM>,  <EM>CommitTrans</EM>, 
	<EM>RollbackTrans</EM>. We call transactions controlled in this way 'ADO Transactions'. 
	<LI>Through COM+ services. Transaction is started by instantiating transactional class. 
	Each object participating in transaction "votes" on it using <EM>SetAbort</EM>, 
	<EM>SetComplete</EM>, <EM>DisableCommit</EM>, <EM>EnableCommit</EM> methods of object's context. 
	Transaction is committed or aborted after returning from 
	top method of object that initiated the transaction, and the outcome is determined by 
	participating objects' "votes". We call transactions controlled in this way 'COM+ Transactions'. 
</UL>
<p>CLASSter can implement support for either of these methods, or even for both of them
with auto-detection of the environment, depending on your selection in [Transactions] page. 
Although the names of transaction control methods in your database class remain the same, 
there are differences in how your code executes transaction control. 
The following sections explain some details for each case. 
<table border='0' cellpadding=0  width='100'> <tr valign='top'><td align=right>
<a href="#Contents">Contents</a></table>
 
<HR>
<a name="ADOTrans"/>
<h3>ADO Transactions</h3>
<p>If you select this method of controlling transactions in your application then you code
 is straightforward: you start, commit or abort transactions by calling 
methods of your database class: 
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
<font color="#000080">Public</font> <font color="#000080">Sub</font> UpdateOrderStatus(<font color="#000080">ByVal</font> AnOrderID <font color="#000080">As</font> <font color="#000080">Long</font>, <font color="#000080">ByVal</font> AStatus <font color="#000080">As</font> <font color="#000080">Long</font>)
    <font color="#000080">On</font> <font color="#000080">Error</font> <font color="#000080">GoTo</font> ErrHandler
    <font color="#000080">Set</font> objMainDB = New clsMainDB
    <font color="#000080">With</font> objMainDB
        .ConnectionString = CONNECT_STRING
        .BeginTransaction
        .ExecCustOrderUpdateStatus AnOrderID, AStatus
        .SetComplete
    <font color="#000080">End</font> <font color="#000080">With</font>
    <font color="#000080">Exit</font> <font color="#000080">Sub</font>
ErrHandler:
    <font color="#000080">If</font> <font color="#000080">Not</font> objMainDB Is Nothing <font color="#000080">Then</font> objMainDB.SetAbort
    Err.Raise vbObjectError + 1, <font color="#808080">&quot;UpdateOrderStatus&quot;</font>, <font color="#808080">&quot;Error updating status&quot;</font>
<font color="#000080">End</font> <font color="#000080">Function</font>
</pre></code>
</td></tr></table>
<p>Honestly, we do not recommend doing things in this way. 
The reason is poor error handling - there is much more to be done in error handler than shown in this example.
One important note: your database class maintains internal flag, which is set when ADO transaction is started.
<EM>SetAbort</EM> method checks this flag, and it attempts to abort the transaction only 
if this flag is set, i.e. if transaction is in progress. 
If there is no transaction it does nothing. In the above example error could 
happen before the transaction started, in which case there is nothing to abort in error handler. 
<EM>SetAbort</EM> method will detect this and will do nothing.  
<P>What we recommend is using HuntERR library for error handling. Here is what your code may look like:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
<font color="#000080">Public</font> <font color="#000080">Sub</font> UpdateOrderStatus(<font color="#000080">ByVal</font> AnOrderID <font color="#000080">As</font> <font color="#000080">Long</font>, <font color="#000080">ByVal</font> AStatus <font color="#000080">As</font> <font color="#000080">Long</font>)
    <font color="#000080">On</font> <font color="#000080">Error</font> <font color="#000080">GoTo</font> errHandler
    <font color="#000080">Set</font> objMainDB = New clsMainDB
    <font color="#000080">With</font> objMainDB
        .ConnectionString = CONNECT_STRING
        .BeginTransaction
        .ExecCustOrderUpdateStatus AnOrderID, AStatus
        .SetComplete
    <font color="#000080">End</font> <font color="#000080">With</font>
    <font color="#000080">Exit</font> <font color="#000080">Sub</font>
errHandler:
    ErrorIn <font color="#808080">&quot;clsBiz.UpdateOrderStatus(AnOrderID,AStatus)&quot;</font>, _
		Array(AnOrderID, AStatus), EA_DFTRBK, objMainDB
<font color="#000080">End</font> <font color="#000080">Sub</font>
</pre></code>
</td></tr></table>
<p>We refer you to HuntERR documentation for more information.
<table border='0' cellpadding=0  width='100'> <tr valign='top'><td align=right>
<a href="#Contents">Contents</a></table>
 
<HR>
<a name="COMPTrans"/>
<h3>COM+ Transactions</h3>
<p>COM+ transactions are different from ADO transactions in many ways, but CLASSter hides many of the 
differences inside implementation of transaction control methods. 
<p>You don't start COM+ transaction by calling some method. Instead, you initiate 
transaction by creating instance of transactional object, which works as transaction initiator. 
In the simplest case your database class can be such a transaction initiator. 
You register your database class in COM+ with 'Requires Transaction' attribute. 
<EM>BeginTransaction</EM> method does nothing in case of COM+ transactions, 
<EM>SetComplete</EM> and <EM>SetAbort</EM> call corresponding methods of object's context object. 
If you don't use HuntERR for error handling then your code may look like this:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
<font color="#000080">Public</font> <font color="#000080">Sub</font> UpdateOrderStatus(<font color="#000080">ByVal</font> AnOrderID <font color="#000080">As</font> <font color="#000080">Long</font>, <font color="#000080">ByVal</font> AStatus <font color="#000080">As</font> <font color="#000080">Long</font>)
    <font color="#000080">On</font> <font color="#000080">Error</font> <font color="#000080">GoTo</font> errHandler
    <font color="#000080">Set</font> objMainDB = CreateObject(<font color="#808080">&quot;BizLib.clsMainDB&quot;</font>)
    <font color="#008000">'Transaction started</font>
    <font color="#000080">With</font> objMainDB
        .ConnectionString = CONNECT_STRING
        .ExecCustOrderUpdateStatus AnOrderID, AStatus
        .SetComplete
    <font color="#000080">End</font> <font color="#000080">With</font>
    <font color="#000080">Exit</font> <font color="#000080">Sub</font>
errHandler:
    GetObjectContext.SetAbort
    Err.Raise vbObjectError + 1, <font color="#808080">&quot;UpdateOrderStatus&quot;</font>, <font color="#808080">&quot;UpdateOrderStatus failed.&quot;</font>
<font color="#000080">End</font> <font color="#000080">Sub</font>
</pre></code>
</td></tr></table>
<p>Although database class may call <EM>GetObjectContext.SetAbort</EM> automatically, 
you still need to call it in error handler - error could happen outside database class, before
or after you execute database operation. 
<p>There are some problems with using your database class as transaction initiator. 
First, to make read operations  more efficient you have to put them in separate 
non-transactional class. You end up with two classes for your
database - non-transactional for read operations, and transactional for updates/inserts. 
The second problem is that you cannot span transaction over several databases,
and thus cannot use the main benefit provided by COM+ - executing distributed transactions.  
<p>The solution to this problems is our first recommendation - to use separate class as 
transaction initiator. We provide source code of <EM>ujTransaction</EM> class, which can be used 
as such a COM+ - helper class. Here is how it works. 
<p>You include ujTransaction class into your application, and  
configure it in COM+ services with 'Requires Transaction' attribute. 
<p>You start transaction in your code by creating instance of ujTransaction class. Then you 
create one or more instances of your database class and include them into 
the scope of transaction by creating them using <EM>ujTransaction.CreateInstance</EM> method. 
After executing database operations through your database
class you commit transaction by calling <EM>ujTransaction.SetComplete</EM>, and abort it
if necessary by calling <EM>ujTransaction.SetAbort</EM>.
<p>Our second recommendation is again to use HuntERR for error handling. HuntERR 
fully supports the described technique. It may call <EM>ujTransaction.SetAbort</EM> method 
in error handler if you provide a reference to your <EM>ujTransaction</EM> instance.   
<p>Let's look at example.  Suppose we are implementing "funds transfer" 
method, with transactional updates in two databases.   Here is what your code may look like:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
<font color="#000080">Public</font> <font color="#000080">Sub</font> Transfer(<font color="#000080">ByVal</font> AcctFrom <font color="#000080">As</font> <font color="#000080">String</font>, <font color="#000080">ByVal</font> AcctTo <font color="#000080">As</font> <font color="#000080">String</font>, _
        <font color="#000080">ByVal</font> Amount <font color="#000080">As</font> Currency)
    <font color="#000080">On</font> <font color="#000080">Error</font> <font color="#000080">GoTo</font> errHandler
    <font color="#000080">Dim</font> objTrans <font color="#000080">As</font> ujTransaction, objBranch1 <font color="#000080">As</font> clsDB, objBranch2 <font color="#000080">As</font> clsDB
    <font color="#000080">Set</font> objTrans = CreateObject(<font color="#808080">&quot;MyLib.ujTransaction&quot;</font>)
    <font color="#000080">With</font> objTrans
        <font color="#000080">Set</font> objBranch1 = .CreateInstance(<font color="#808080">&quot;MyLib.clsDB&quot;</font>)
        objBranch1.ConnectionString = CONNECT_BRANCH1
        <font color="#000080">Set</font> objBranch2 = .CreateInstance(<font color="#808080">&quot;MyLib.clsDB&quot;</font>)
        objBranch2.ConnectionString = CONNECT_BRANCH2
        <font color="#008000">'Transaction started, objBranch1 and objBranch2 are included in its scope</font>
        objBranch1.ExecAcctDebit AcctFrom, Amount
        objBranch2.ExecAcctCredit AcctTo, Amount
        .SetComplete <font color="#008000">'Commit</font>
    <font color="#000080">End</font> <font color="#000080">With</font>
    <font color="#000080">Exit</font> <font color="#000080">Sub</font>
errHandler:
    ErrorIn <font color="#808080">&quot;clsBiz.Transfer(AcctFrom,AcctTo,Amount)&quot;</font>, _
        Array(AcctFrom, AcctTo, Amount), , , , , objTrans
<font color="#000080">End</font> <font color="#000080">Sub</font>
</pre></code>
</td></tr></table>
<p>If error happens, <EM>ErrorIn</EM> function provided by HuntERR calls <EM>objTrans.SetAbort</EM>. 
It does this whenever it finds an object provided as the last parameter. 
<table border='0' cellpadding=0  width='100'> <tr valign='top'><td align=right>
<a href="#Contents">Contents</a></table>
 

<HR>
<a name="Batch"/>
<h3>Batch Execution</h3>
<p>Batch execution is a powerful feature that CLASSter can add to your 
database class. It can substantially improve you application performance, and can help use 
network and server resources more efficiently. In our never-too-much-resources
world batch execution comes as real efficiency booster with 
almost zero price - very few programming effort is required from you to use it!
<p>Most of the time business logic manipulations involve multiple database operations, 
and therefore require repetitive roundtrips to database server. 
Batch execution allows you to accumulate these operations in one compound batch job, and then 
execute it as one database command in one trip to server. 
<p>The wonderful thing is that this will happen almost at no effort from 
you. You just call <EM>BatchBegin</EM> method, then call database class methods as usual. 
Behind the scene database class does not execute commands
immediately but records them in internal buffer. After completing all database operations
 you call <EM>BatchExec</EM> method, and database class submits all recorded
commands to database server as one batch job. 
<p>Let's look at the example. Suppose you run a CD Web-Store, and 
there is a Web page on your site where your customers can check boxes with their prefered music styles,
and update their email address. 
You store preferences in a separate table, mutliple records for each customer, standard one-to-many
arrangement. 
Here is what your update code may look like:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
    <font color="#000080">With</font> objMainDB
        .BatchBegin
        .ExecSQL <font color="#808080">&quot;DELETE FROM tblCustPrefStyles WHERE customer_id = %1 &quot;</font>, CustID
        <font color="#000080">For</font> i = LBound(arrStyleIDs) <font color="#000080">To</font> UBound(arrStyleIDs)
            .ExecCustPrefStyleInsert CustID, arrStyleIDs(i)
        <font color="#000080">Next</font> i
        .ExecSPbyName SP_CUST_EMAIL_UPDATE, PRM_CUST_EMAIL_UPDATE, _
		    Array(CustID, CustEmail)
        .BatchExec
        Debug.Print .BatchText 
    <font color="#000080">End</font> <font color="#000080">With</font>
</pre></code>
</td></tr></table>
<p>In this code fragment we tried to show different things that 
you can do in Batch mode.  You can call stored procedures 
through individual methods of your class, call stored procedures using <EM>ExecSPbyName</EM>, 
or execute direct SQL statements. 
<p>After calling <EM>BatchBegin</EM> database class starts recording your operations.
After completing recording you call <EM>BatchExec</EM> to actually apply recorded batch. 
You can wrap this call in transaction by calling <EM>BeginTransaction</EM> before, and <EM>SetComplete</EM>
after calling <EM>BatchExec</EM>. 
<p>Here is what executed batch may look like (for MS SQL Server / Sybase):
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
	DELETE FROM tblCustPrefStyles WHERE customer_id = 123;
	EXEC uspCustPrefStyleInsert 123, 1;
	EXEC uspCustPrefStyleInsert 123, 3;
	EXEC uspCustPrefStyleInsert 123, 4;
	EXEC uspCustPrefStyleInsert 123, 11;
	EXEC uspCustPrefStyleInsert 123, 13;
	EXEC uspCustPrefEmailUpdate 123, 'joe@atjoe.com';
</pre></code>
</td></tr></table>
<p>Number of calls to <EM>uspCustPrefStyleInsert</EM> may vary,  
depending on number of styles that customer selects. 
Compare this solution to what it could be without batch: 
every call must be executed as separate command, each
requiring a trip to database server from application server. 
But when called inside Batch all calls are executed in one command. 
<p>Now suppose that we want our example to work for new customers as well. 
That is, suppose we need to insert new customer record, and then to insert 
dependent preferences records into cross-reference table. 
Here comes the problem: we don't know in advance the primary key of 
newly inserted customer. If we simply try to add a call to uspCustInsert stored
procedure at the beginning of our batch, this wouldn't work - this stored procedure
wouldn't be executed when we call <EM>ExecCustInsert</EM> VB method, 
new primary key is not assigned, so we don't have it's value for the following 
calls to <EM>uspCustPrefStyleInsert</EM>
<p>Looks like you cannot do things like this in Batch mode? One solution would
be to insert customer record outside batch, get the customer id, and then 
use it in batch mode to insert dependent records. 
<p>Fortunately, there is a better solution, and CLASSter-generated 
database class supports the way to execute operations involving newly generated keys. 
The idea is to declare a variable 
inside batch code that would accept the value of newly inserted key from 
<EM>uspCustInsert</EM> stored procedure, and then carry it to <EM>uspCustPrefStyleInsert</EM> calls. 
<p><EM>BatchDeclareVar</EM> method of your database class allows to declare such a variable. 
The effect of this method is the following. First, it inserts variable declaration into 
batch text (declaration syntax depends on the type of database server you are using).  
When declaring a variable you specify it's name, data type, optional initial value, and 
optional list of stored procedure parameters, for which this variable will be used. 
In all following calls to stored procedures inside batch database class will check for 
parameters with names matching the names you specified when you declared a variable. 
If you didn't specify the list then parameters are checked against variable name itself. 
If there is a match, then instead of a value specified in a call to Exec... VB method, 
the batch processor puts a reference to the declared variable.  
<p>Let's look at the example. 
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
    <font color="#000080">With</font> objMainDB
        .BatchBegin
        .BatchDeclareVar <font color="#808080">&quot;@CustID&quot;</font>, <font color="#808080">&quot;INT&quot;</font>
        .ExecCustInsert CustID, strFirstName, strLastName, strEmail
        .ExecCustAddrInsert AddrID, CustID, strStreet, strCity, strState, strZip
        <font color="#000080">For</font> i = LBound(arrStyleIDs) <font color="#000080">To</font> UBound(arrStyleIDs)
            .ExecCustPrefStyleInsert CustID, arrStyleIDs(i)
        <font color="#000080">Next</font> i
        .BeginTransaction
        .BatchExec
        .SetComplete
    <font color="#000080">End</font> <font color="#000080">With</font>
</pre></code>
</td></tr></table>   
<p>As you see we made the example a bit more complex (and a bit more real): 
we insert customer record, add address into address table, and insert style preferences
records. Here is what finally executed batch would look like for MS SQL Server/ Sybase servers:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
	DECLARE @CustID INT;
	EXEC uspCustInsert @CustID OUTPUT, 'John', 'Smith', 'johns@cust.com';
	EXEC uspCustAddressInsert 0, @CustID, 
	           '111 22 Street #3', 'Seattle', 'WA', '95555'; 
	EXEC uspCustPrefStyleInsert @CustID, 1;
	EXEC uspCustPrefStyleInsert @CustID, 3;
	EXEC uspCustPrefStyleInsert @CustID, 4;
	EXEC uspCustPrefStyleInsert @CustID, 11;
	EXEC uspCustPrefStyleInsert @CustID, 13;
</pre></code>
</td></tr></table>
<p><EM>Note: line break in uspCustAddressInsert was added for readability, it is not part of 
the batch. </EM>
<p>A few comments to batch text. First, batch code is server-specific. For Oracle server
it would be slightly different. Second, as we expected, batch processor (code inside 
database class) has put references to @CustID variable to all calls to stored procedures that expect 
customer ID. We assume that corresponding parameter names are the same as our variable name 
<EM>@CustID</EM>, and batch processor was able to match them directly. Thirdly, batch processor added
OUTPUT attribute to @CustID reference in the first call. MS SQL Server requires this for 
OUTPUT parameters if you want to return the value from stored procedure. Batch processor 
does this automatically whenever it finds that parameter is OUTPUT. 
<p>Finally, we assume that <EM>uspCustAddressInsert</EM> returns address ID - primary key of newly 
inserted address record. We don' need this value, so we didn't take any steps to preserve
it in some variable. Batch processor simply inserted 0 - a value  we provided in <EM>AddrID</EM> VB variable. 
This is not allowed by Oracle server - you have to declare a variable to accept the returned 
value, no matter whether you need it or not. 
<p>And last but not least important question: how to return the newly generated key 
to the calling VB code?  For MS SQL Server it is relatively simple: just make a SELECT statement
at the end of the batch on all variables that you want to return. You will find a value in 
returned <EM>Recordset</EM>. For Oracle server it is not possible. If you do 
need to return the key value, you should probably generate the key outside the batch, and then
use it to execute all other actions in a batch. 
<table border='0' cellpadding=0  width='100'> <tr valign='top'><td align=right>
<a href="#Contents">Contents</a></table>

<HR>
<a name="XML"/>
<h3>XML: Two Levels of XML Support</h3>
<p>CLASSter provides support of XML 
processing at two levels: Basic and Advanced. You specify the XML support options for your database 
class in [Class Functionality / ADO] page in CLASSter. You may have only one of two
levels, or you may choose to have both - they are completely independent. 
XML functions use some string manipulation utilities located in <EM>ctrXMLUtils.Bas</EM> 
module provided with CLASSter. If you decide to use XML functionality (any level)
you should include this module into your VB project. 
<h4>Basic XML Support</h4>
<p>At this level your database class uses 
XML functionality provided by ADO library. With the functions provided at this level
you can retrieve Recordset returned by last database operation as XML string
(both Recordset schema and data). Alternatively you can retrieve data only, without
schema, with custom element names for Recordset and Record elements. 
Finally, you can retrieve the data from entire sequence of recordsets returned by database 
operation in one customized XML message. 
<p>The amount of customization you may apply to resulting XML message is limited, 
that is why we call this level Basic. You cannot retrieve subset of recordset 
fields in a message; you cannot alter attribute names that hold data - they match  
field names; you cannot specify data formatting inside the message; 
finally, you cannot alter the internal structure of XML 
message. 
<h4>Advanced XML Support</h4>
<p>Advanced XML support allows your application to produce a fully customized 
XML message in just one call to class method. You can specify the subset of data
fields to be included into XML message, specify element/attribute names corresponding 
to Recordset fields, and specify data formatting for particular fields and/or data types. 
<p>The following two sections provide more detailed information about XML functionality 
provided at both levels. 
<table border='0' cellpadding=0  width='100'> <tr valign='top'><td align=right>
<a href="#Contents">Contents</a></table>

<HR>
<a name="XMLBasic"/>
<h3>Basic XML Functionality</h3>
<p>This level of XML functionality is provided by three public functions that CLASSter
includes into your class: <a href="CTR_RefGuide.htm#xmlGetRecordset">xmlGetRecordset</a>, 
<a href="CTR_RefGuide.htm#xmlGetData">xmlGetData</a>,
<a href="CTR_RefGuide.htm#xmlGetDataAll">xmlGetDataAll</a>.
<p><EM>xmlGetRecordset</EM> function returns XML representation of Recordset, both schema (recordset
structure) and data, in the way it is saved by <EM>Recordset.Save</EM> method. You call this method
after executing database operation that returns data in Recordset:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
    <font color="#000080">With</font> objMainDB
        .ExecSQL <font color="#808080">&quot;Select * from Customers&quot;</font>
        xmlCustomers = .xmlGetRecordset
    <font color="#000080">End</font> <font color="#000080">With</font>
</pre></code>
</td></tr></table>
<p>Resulting XML message is shown in <a target="CtrSample" href="XMLSamplesBasic.htm#Lst1">Listing 1.</a>
<p>As you see it includes schema and data elements. Element names in data section have 
ADO-assigned names. If you want to retrieve data only, and additionally to have more 
business-meaningful name for elements in XML message, you should use <EM>xmlGetData</EM> method:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
    CustID = <font color="#808080">&quot;ALFKI&quot;</font>
    <font color="#000080">With</font> objMainDB
        .ExecSQL <font color="#808080">&quot;Select * from Orders Where CustID='%1'&quot;</font>, CustID
        xmlOrders = .xmlGetData(<font color="#808080">&quot;Orders&quot;</font>, <font color="#808080">&quot;Order&quot;</font>)
    <font color="#000080">End</font> <font color="#000080">With</font>
</pre></code>
</td></tr></table>
<p>The resulting XML string may look like shown in 
<a target="CtrSample" href="XMLSamplesBasic.htm#Lst2">Listing 2.</a>
<p>Parameters specifying element names are optional, with default values "Recordset" and "Record". 
"Orders" element that we specify as the first parameter is an element name 
for the root element of resulting XML message. 
<EM>xmlGetData</EM> automatically enclosed it into '&lt;' and '&gt;' characters to form the 
opening tag, and created matching closing tag. 
<P>Sometimes you may need to include into root element some extra information, like references 
to namespaces, processing instructions, etc. In this case you simply provide the full 
representation of opening tag as the first parameter, and closing tag as <EM>ClosingTag</EM> 
(the third) parameter. 
<EM>xmlGetData</EM> checks if <EM>RsDataElem</EM> (the first parameter)
contains '&lt;' character. If it does, it interprets it as opening tag and includes it at the beginning
of the message as is, without any manipulations. Otherwise it interprets it as element name, so it
adds necessary characters to form opening tag. 
<EM>xmlGetData</EM> also looks if <EM>ClosingTag</EM> is provided. If it is, <EM>xmlGetData</EM> includes it as is
at the end of XML string. Otherwise it forms closing tag from <EM>RsDataElem</EM> value. 
<p>The third function <EM>xmlGetDataAll</EM> works with multiple 
recordsets returned by database operation. 
It is included only if you choose to include "Multiple Recordsets Functionality" in 
[Class Functionality / ADO Helper Methods] page in CLASSter. 
<p><EM>Note: Multiple Recordsets functionality is not available for Oracle server and MS Access. </EM>
<p>Suppose you want to retrieve customer information together with his order list. You can do this
by running two SQL statements in one call, and then retrieving combined XML message:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
    CustID = <font color="#808080">&quot;ALFKI&quot;</font>
    <font color="#000080">With</font> objMainDB
        .ExecSQL <font color="#808080">&quot;Select * from Customers Where CustomerID='%1'; &quot;</font> &amp; _
            vbNewLine &amp; <font color="#808080">&quot;Select * from Orders Where CustID='%1'&quot;</font>, CustID
        xmlOrders = .xmlGetDataAll(<font color="#808080">&quot;CustomerInfo&quot;</font>, _
			<font color="#808080">&quot;Customers,Orders&quot;</font>, <font color="#808080">&quot;Customer,Order&quot;</font>)
    <font color="#000080">End</font> <font color="#000080">With</font>
</pre></code>
</td></tr></table>
<p>The result may look like message shown in 
<a target="CtrSample" href="XMLSamplesBasic.htm#Lst3">Listing 3.</a>
<p>Note, that it is important that we have two concatenated SQL statements in one call to 
<EM>ExecSQL</EM>, not two separate calls. <EM>xmlGetDataAll</EM> 
returns all recordsets returned by LAST operation. 
<p>As with <EM>xmlGetData</EM> function there is optional <EM>ClosingTag</EM> parameter. Instead of providing
name for root element ("CustomerInfo" in the last example) you may provide full string for opening tag. 
In this case you should provide matching <EM>ClosingTag</EM> value. 
<p>In our case we have only one customer. So it probably makes sense to include Customer element directly
under the root element, without enclosing it into Customers element. To do this, simply provide emtpy
element name in the second parameter, like this: 
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
        xmlOrders = .xmlGetDataAll(<font color="#808080">&quot;CustomerInfo&quot;</font>, <font color="#808080">&quot;,Orders&quot;</font>, <font color="#808080">&quot;Customer,Order&quot;</font>)
</pre></code>
</td></tr></table>
<p>The result may look like message shown in 
<a target="CtrSample" href="XMLSamplesBasic.htm#Lst4">Listing 4.</a>
<table border='0' cellpadding=0  width='100'> <tr valign='top'><td align=right>
<a href="#Contents">Contents</a></table>

<HR><a name="XMLAdvanced"/>
<h3>Advanced XML Functionality</h3>
<p>This XML functionality level is provided by one function: <a href="CTR_RefGuide.htm#xmlGetDataAdv">xmlGetDataAdv</a>.
Although its name is quite similar to functions in Basic XML level, and it does similar thing, 
it works completely differently. It creates resulting XML message by navigating through Recordset 
records one-by-one, and constructing XML from data in recordset fields 
according to specifications provided in <EM>ZRowSpecs</EM> parameter. 
<p>If your application is XML-powered then you probably agree that building XML messages from data
retrieved from database involves a lot of coding. The resulting code is really tricky, complex,
 and often troublesome - it needs a lot of time for debugging and testing before you get it working.  
Your code moves through recordset, creates MS XML DOM document objects, and builds the tree of 
resulting XML message. What <EM>xmlGetDataAdv</EM> function does is it takes over this annoying task. You get your 
customized XML message in just one call! In this section we'll show you how you can do this.  
<p>We'll demonstrate <EM>xmlGetDataAdv</EM> functionality using one and the same SQL statement that
retrieves all customers from Germany in Northwind database. Let's first show the non-customized
recordset data as it is returned by <EM>xmlGetData</EM>. Here is the code: 
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
    Country = <font color="#808080">&quot;Germany&quot;</font>
    <font color="#000080">With</font> objMainDB
       .ExecSQL <font color="#808080">&quot;Select * from Customers Where country='%1'&quot;</font>, Country
       xmlCust = .xmlGetData(<font color="#808080">&quot;Customers&quot;</font>, <font color="#808080">&quot;Customer&quot;</font>)
    <font color="#000080">End</font> <font color="#000080">With</font>
</pre></code>
</td></tr></table>
<p>And here is <a target="xmlsample" href="XMLSamplesAdv.htm#Lst5">XML data</a>.
<p>Now let's turn to <EM>xmlGetDataAdv</EM> function:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
<font color="#000080">Public</font> <font color="#000080">Function</font> xmlGetDataAdv(<font color="#000080">ByVal</font> RsDataElem <font color="#000080">As</font> <font color="#000080">String</font>, _
                            <font color="#000080">ByVal</font> ZRowSpecs <font color="#000080">As</font> <font color="#000080">String</font>, _
                            <font color="#000080">Optional</font> <font color="#000080">ByVal</font> SkipRecords <font color="#000080">As</font> <font color="#000080">Long</font> = 0, _
                            <font color="#000080">Optional</font> <font color="#000080">ByVal</font> IncludeMaxRecords <font color="#000080">As</font> <font color="#000080">Long</font> = -1, _
                            <font color="#000080">Optional</font> <font color="#000080">ByVal</font> ClosingTag <font color="#000080">As</font> <font color="#000080">String</font>) <font color="#000080">As</font> <font color="#000080">String</font>
</pre></code>
</td></tr></table>
<p>As with XML functions we discussed before, when calling this function you specify the root element name in 
<EM>RsDataElem</EM> parameter. Alternatively you can specify the complete opening tag in <EM>RsDataElem</EM>, and matching closing tag in 
<EM>ClosingTag</EM> parameter. You can also specify how many records to skip at the beginning of recordset, and how
many records to include after skipped records. 
<p>In <EM>ZRowSpecs</EM> String parameter you specify the XML structure of each element containing data from one record 
from Recordset. This structure would be repeated for every record being included in XML message. You always start 
<EM>ZRowSpecs</EM> string with element name that will represent a record in XML message. The element name should be followed 
by list of attributes/field specifications that you want to include into XML message. The simplest way to go is to
list field/attribute names with '@' prefix:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
xmlRes = .xmlGetDataAdv(<font color="#808080">&quot;Customers&quot;</font>, <font color="#808080">&quot;Customer(@CustomerID,@CompanyName,@ContactName)&quot;</font>)
</pre></code>
</td></tr></table>
<p>The resulting XML message
shown on <a target="xmlsample" href="XMLSamplesAdv.htm#Lst6">Listing 6</a> contains 
only attributes we specified in <EM>ZRowSpecs</EM>.
<p>Now let's limit records included into XML message to records #3, #4 and #5:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
xmlRes = .xmlGetDataAdv(<font color="#808080">&quot;Customers&quot;</font>, _
    <font color="#808080">&quot;Customer(@CustomerID,@CompanyName,@ContactName)&quot;</font>, 2, 3)
</pre></code>
</td></tr></table>
<p>The resulting <a target="xmlsample" href="XMLSamplesAdv.htm#Lst7">XML message</a>
shown on <EM>Listing 7</EM> contains only records from #3 to #5.
<p>So far we had field data represented as attributes. If we include field name without 
'@' prefix, the field value will be shown as sub-element. 
<a target="xmlsample" href="XMLSamplesAdv.htm#Lst8">Listing 8</a>
shows the VB call and resulting XML message.
<p>To have an attribute/element name different from field name you must 
specify the following token for the field: @AttrName=FieldName or ElemName=FieldName.
<a target="xmlsample" href="XMLSamplesAdv.htm#Lst9">Listing 9</a>
shows how this may be done. 
<p>You may apply customized formatting to data inside XML message. 
To use this part of functionality your database class should also have 
field-formatting functionality included by CLASSter. You should check the 
corresponding box in [Class Functionality/ADO Helper Functions] page. 
For our demo we need one more field for formatting in our Recordset, so 
let's add current date/time field to SELECT statement, and specify 
format for all date/time fields:
<table border='0' cellpadding=0 width='100%'> <tr valign='top'><td width='20pt'><td bgcolor=#F0F0F0>
<code><pre>
.ExecSQL <font color="#808080">&quot;Select *, GETDATE() As CurrDate from Customers Where country='%1'&quot;</font>, Country
.FormatSet <font color="#808080">&quot;DD-MMM-YYYY&quot;</font>, adDBTimeStamp
xmlRes = .xmlGetDataAdv(<font color="#808080">&quot;Customers&quot;</font>, _
      <font color="#808080">&quot;Customer(@CustomerID,@CurrDate,@Company=CompanyName,Contact=ContactName)&quot;</font>, 2, 3)
</pre></code>
</td></tr></table>
<p><a target="xmlsample" href="XMLSamplesAdv.htm#Lst10">Listing 10</a>
shows the result XML message. 
<p><EM>xmlGetDataAdv</EM> supports two pseudo-fields identified by single and doubled '#' 
character. The single '#' refers to absolute record position in recordset;
doubled '#' character refers to relative position, with 1 being the first record 
included into XML message. You can also specify a constant value for the attribute.
Simply put a constant value in single quotes instead of field name 
to the right from = character.
<a target="xmlsample" href="XMLSamplesAdv.htm#Lst11">Listing 11</a>
shows the sample VB call and result XML message. 
<p>Finally, you can push data (attributes and elements) inside sub-element. 
To do this, simply specify sub-element name, and put specifications for 
element content in parenthesis immediately after the name. 
In <a target="xmlsample" href="XMLSamplesAdv.htm#Lst12">Listing 12</a> we show 
customer address data inside sub-element <EM>CustAddress</EM>.
<table border='0' cellpadding=0  width='100'> <tr valign='top'><td align=right>
<a href="#Contents">Contents</a></table>

<HR><a name="Problems"/>
<h3>Known Problems</h3>
<h4>Oracle: Access Violation with Nullable IN/OUT Varchar Parameter </h4>
<p>This failure was detected with Microsoft OLE DB Provider for 
Oracle. If your stored procedure has a nullable
<EM>Varchar2</EM> IN/OUT parameter, you send Null as an input value, 
and stored procedure assigns Non-null value to it, then AFTER
returning from stored procedure back to client 
<EM>Access Violation</EM> fault happens on the client. This happens ONLY if all
conditions are met: Parameter is <EM>Varchar2</EM>, parameter is IN/OUT, input
value Null, output value is not Null. The solution: avoid this combination
of parameter attributes/values.  
<h4>Access: Extra Variant Parameters for Some Queries </h4>
<p>For some queries MS Access requires additional parameters, which are 
not defined as parameters in queries themselves. 
These parameters are Variants, and their values may be set to Null. 
This happens for example for UNION queries.
The nature of this strange behavior is unknown to us. 
CLASSter detects this situation, and adds these parameters to method 
in your database class. If you find such extra parameters in generated 
methods - it's not a bug, these parameters need to be present in 
Command.Parameters collection, otherwise MS Access will reject the call. 
Your code should simply send Null as values for these extra parameters.  
<h4>Sybase: Doesn't support output parameters</h4>
<p>Sybase ASE server doesn't support  OUTPUT parameters with ADO calls, so 
for this server all parameters in all generated methods are <EM>ByVal</EM>. 

<HR>
<p>Copyright <STRONG>URFIN JUS</STRONG> (<A HREF="http://www.urfinjus.net">www.urfinjus.net</A>), 2001-2002. All Rights Reserved.












   

</BODY>
</HTML>

